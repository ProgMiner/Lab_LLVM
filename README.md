# Lab_LLVM

Графическая игра «Жизнь»

## Сборка

```bash
cmake -B cmake-debug-build && cmake --build cmake-debug-build
```

## Запуск

Оригинальное приложение:

```bash
./cmake-debug-build/orig
```

Генерация LLVM IR из ASM и интерпретация:

```bash
./cmake-debug-build/llvm ./main.in
```

## Описание архитектуры

### Регистры общего назначения

Виртуальный процессор обладает двумя наборами регистров общего назначения:

- Регистры `i32` для хранения числовых 4-байтовых значений: `iX`, где `X` — число от 1 до 8
- Регистры `ptr` для хранения указателей на память: `mX`, где `X` — число от 1 до 8

### Метки

В любом месте кода может быть установлена символьная метка вида `label:`,
где `label` — это название метки

### Набор инструкций

Каждая инструкция имеет вид `opcode arg1 arg2 ... argN`, где `opcode` — мнемоническое название инструкции,
`argI` — операнд инструкции

Разные инструкции принимают разные виды операндов:
- `label` — метка
- `imm` — непосредственное знаковое целочисленное значение типа `i32`
- `reg` — название регистра типа `i32`
- `i/r` — `imm` или `reg`
- `mem` — название регистра типа `ptr`

#### Изменение потока управления

- `goto label` — безусловный переход на метку `arg2`
- `if i/r label` — переход на метку `arg2` если `arg1` содержит ненулевое значение

#### Арифметические операции

- `movi i/r reg` — `arg2 = arg1`
- `addi i/r reg` — `arg2 += arg1`
- `mul i/r reg` — `arg2 *= arg1`
- `and i/r reg` — `arg2 &= arg1`
- `neq i/r i/r reg` — `arg2 = arg1 ≠ arg2`

#### Управление памятью

- `buffer imm mem` — выделяет массив типа `[i32 x arg1]` и присваивает указатель на него в `arg2`
- `store i/r mem` — `*arg2 = arg1`
- `movm mem mem` — `arg2 = arg1`
- `addm i/r mem` — `arg2 += arg1`, причём `arg1` задаёт число ячеек массива, а не число байт

#### Работа с битовыми векторами

- `get_bit mem i/r reg` — получает бит под номером `arg2` из битового вектора по указателю `arg1`
  и сохраняет его значение в `arg3`
- `set_bit mem i/r` — устанавливает бит под номером `arg2` в битовом векторе по указателю `arg1`
  в значение 1
- `clear_bit mem i/r` — устанавливает бит под номером `arg2` в битовом векторе по указателю `arg1`
  в значение 0

#### Прочие операции

- `rand reg` — устанавливает `arg1` в случайное значение с равномерным распределением $`[0, 2^{32} - 1]`$
- `set_pixel i/r i/r i/r` — устанавливает значение пикселя в экранном буфере с координатами `(arg1, arg2)`
  в значение 1, если `arg2` не равен нулю, иначе в значение 0
- `flush` — сбрасывает экранный буфер на экран (отображает содержимое)
- `dumpi` — единовременный вывод значений всех регистров типа `i32` в стандартный поток вывода
